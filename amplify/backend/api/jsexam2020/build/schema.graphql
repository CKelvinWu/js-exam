type Room {
  id: ID!
  test: Test
  subjectId: String
  description: String
  host: JEUser
  createTime: AWSDateTime
  password: String
  users(filter: ModelJEUserFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelJEUserConnection
  currentRecord: Record
}

type JEUser {
  id: ID!
  name: String
  room: Room
  team: Team
  test: Test
  hostTest: Test
}

type Team {
  id: ID!
  name: String
  description: String
  users(filter: ModelJEUserFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelJEUserConnection
  questionSet(filter: ModelQuestionSetFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelQuestionSetConnection
}

type Test {
  id: ID!
  room: Room
  team: Team
  subjectId: String
  users(filter: ModelJEUserFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelJEUserConnection
  host: JEUser
  description: String
  timeBegin: AWSDateTime
  timeEnd: AWSDateTime
  records(filter: ModelRecordFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelRecordConnection
  status: String!
  tags: [String]
}

type Record {
  id: ID!
  subjectId: String
  syncCode: String
  interviewer: JEUser
  timeBegin: AWSDateTime
  timeEnd: AWSDateTime
  status: String
  comment(filter: ModelCommentFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelCommentConnection
  history(filter: ModelHistoryFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelHistoryConnection
  ques: QuesSnapshot
  question: QuestionSnapshot
  test: Test
  room: Room
}

type Comment {
  author: String
  time: AWSDateTime
  content: String
  record: Record
}

type History {
  id: ID!
  time: AWSDateTime
  code: String!
  record: Record
  snapComments(filter: ModelSnapCommentFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelSnapCommentConnection
}

type SnapComment {
  id: ID!
  time: AWSDateTime
  author: String
  content: String!
  history: History
}

type QuesSnapshot {
  type: String
  name: String
  content: String
  test: String
}

type QuestionSnapshot {
  id: ID!
  type: String
  name: String
  content: String
  test: String
  record: Record
}

type QuestionSet {
  id: ID!
  team: Team
  questions(filter: ModelQuestionFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelQuestionConnection
  name: String
  description: String
  tags: [String]
}

type Question {
  id: ID!
  type: String
  questionSet: QuestionSet
  name: String
  content: String
  test: String
  tags: [String]
}

type Subscription {
  onUpdateJEUserByJEUserId(id: String): JEUser @aws_subscribe(mutations: ["updateJEUser"])
  onUpdateTeamByTeamId(id: String): Team @aws_subscribe(mutations: ["updateTeam"])
  onUpdateTestByTestId(id: String): Test @aws_subscribe(mutations: ["updateTest"])
  onUpdateRoomByRoomId(id: String): Room @aws_subscribe(mutations: ["updateRoom"])
  onUpdateRecordByRecordId(id: String): Record @aws_subscribe(mutations: ["updateRecord"])
  onCreateRoom: Room @aws_subscribe(mutations: ["createRoom"])
  onUpdateRoom: Room @aws_subscribe(mutations: ["updateRoom"])
  onDeleteRoom: Room @aws_subscribe(mutations: ["deleteRoom"])
  onCreateJEUser: JEUser @aws_subscribe(mutations: ["createJEUser"])
  onUpdateJEUser: JEUser @aws_subscribe(mutations: ["updateJEUser"])
  onDeleteJEUser: JEUser @aws_subscribe(mutations: ["deleteJEUser"])
  onCreateTeam: Team @aws_subscribe(mutations: ["createTeam"])
  onUpdateTeam: Team @aws_subscribe(mutations: ["updateTeam"])
  onDeleteTeam: Team @aws_subscribe(mutations: ["deleteTeam"])
  onCreateTest: Test @aws_subscribe(mutations: ["createTest"])
  onUpdateTest: Test @aws_subscribe(mutations: ["updateTest"])
  onDeleteTest: Test @aws_subscribe(mutations: ["deleteTest"])
  onCreateRecord: Record @aws_subscribe(mutations: ["createRecord"])
  onUpdateRecord: Record @aws_subscribe(mutations: ["updateRecord"])
  onDeleteRecord: Record @aws_subscribe(mutations: ["deleteRecord"])
  onCreateComment: Comment @aws_subscribe(mutations: ["createComment"])
  onUpdateComment: Comment @aws_subscribe(mutations: ["updateComment"])
  onDeleteComment: Comment @aws_subscribe(mutations: ["deleteComment"])
  onCreateHistory: History @aws_subscribe(mutations: ["createHistory"])
  onUpdateHistory: History @aws_subscribe(mutations: ["updateHistory"])
  onDeleteHistory: History @aws_subscribe(mutations: ["deleteHistory"])
  onCreateSnapComment: SnapComment @aws_subscribe(mutations: ["createSnapComment"])
  onUpdateSnapComment: SnapComment @aws_subscribe(mutations: ["updateSnapComment"])
  onDeleteSnapComment: SnapComment @aws_subscribe(mutations: ["deleteSnapComment"])
  onCreateQuestionSnapshot: QuestionSnapshot @aws_subscribe(mutations: ["createQuestionSnapshot"])
  onUpdateQuestionSnapshot: QuestionSnapshot @aws_subscribe(mutations: ["updateQuestionSnapshot"])
  onDeleteQuestionSnapshot: QuestionSnapshot @aws_subscribe(mutations: ["deleteQuestionSnapshot"])
  onCreateQuestionSet: QuestionSet @aws_subscribe(mutations: ["createQuestionSet"])
  onUpdateQuestionSet: QuestionSet @aws_subscribe(mutations: ["updateQuestionSet"])
  onDeleteQuestionSet: QuestionSet @aws_subscribe(mutations: ["deleteQuestionSet"])
  onCreateQuestion: Question @aws_subscribe(mutations: ["createQuestion"])
  onUpdateQuestion: Question @aws_subscribe(mutations: ["updateQuestion"])
  onDeleteQuestion: Question @aws_subscribe(mutations: ["deleteQuestion"])
}

type Jtest {
  id: ID!
  name: String
  alias: String
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelRoomConnection {
  items: [Room]
  nextToken: String
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelRoomFilterInput {
  id: ModelIDInput
  subjectId: ModelStringInput
  description: ModelStringInput
  createTime: ModelStringInput
  password: ModelStringInput
  and: [ModelRoomFilterInput]
  or: [ModelRoomFilterInput]
  not: ModelRoomFilterInput
}

type Query {
  getRoom(id: ID!): Room
  listRooms(filter: ModelRoomFilterInput, limit: Int, nextToken: String): ModelRoomConnection
  getJEUser(id: ID!): JEUser
  listJEUsers(filter: ModelJEUserFilterInput, limit: Int, nextToken: String): ModelJEUserConnection
  getTeam(id: ID!): Team
  listTeams(filter: ModelTeamFilterInput, limit: Int, nextToken: String): ModelTeamConnection
  getTest(id: ID!): Test
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection
  getRecord(id: ID!): Record
  listRecords(filter: ModelRecordFilterInput, limit: Int, nextToken: String): ModelRecordConnection
  getComment(id: ID!): Comment
  listComments(filter: ModelCommentFilterInput, limit: Int, nextToken: String): ModelCommentConnection
  getHistory(id: ID!): History
  listHistorys(filter: ModelHistoryFilterInput, limit: Int, nextToken: String): ModelHistoryConnection
  getSnapComment(id: ID!): SnapComment
  listSnapComments(filter: ModelSnapCommentFilterInput, limit: Int, nextToken: String): ModelSnapCommentConnection
  getQuestionSnapshot(id: ID!): QuestionSnapshot
  listQuestionSnapshots(filter: ModelQuestionSnapshotFilterInput, limit: Int, nextToken: String): ModelQuestionSnapshotConnection
  getQuestionSet(id: ID!): QuestionSet
  listQuestionSets(filter: ModelQuestionSetFilterInput, limit: Int, nextToken: String): ModelQuestionSetConnection
  getQuestion(id: ID!): Question
  listQuestions(filter: ModelQuestionFilterInput, limit: Int, nextToken: String): ModelQuestionConnection
}

input CreateRoomInput {
  id: ID
  subjectId: String
  description: String
  createTime: AWSDateTime
  password: String
  roomTestId: ID
  roomCurrentRecordId: ID
}

input UpdateRoomInput {
  id: ID!
  subjectId: String
  description: String
  createTime: AWSDateTime
  password: String
  roomTestId: ID
  roomCurrentRecordId: ID
}

input DeleteRoomInput {
  id: ID
}

type Mutation {
  createRoom(input: CreateRoomInput!, condition: ModelRoomConditionInput): Room
  updateRoom(input: UpdateRoomInput!, condition: ModelRoomConditionInput): Room
  deleteRoom(input: DeleteRoomInput!, condition: ModelRoomConditionInput): Room
  createJEUser(input: CreateJEUserInput!, condition: ModelJEUserConditionInput): JEUser
  updateJEUser(input: UpdateJEUserInput!, condition: ModelJEUserConditionInput): JEUser
  deleteJEUser(input: DeleteJEUserInput!, condition: ModelJEUserConditionInput): JEUser
  createTeam(input: CreateTeamInput!, condition: ModelTeamConditionInput): Team
  updateTeam(input: UpdateTeamInput!, condition: ModelTeamConditionInput): Team
  deleteTeam(input: DeleteTeamInput!, condition: ModelTeamConditionInput): Team
  createTest(input: CreateTestInput!, condition: ModelTestConditionInput): Test
  updateTest(input: UpdateTestInput!, condition: ModelTestConditionInput): Test
  deleteTest(input: DeleteTestInput!, condition: ModelTestConditionInput): Test
  createRecord(input: CreateRecordInput!, condition: ModelRecordConditionInput): Record
  updateRecord(input: UpdateRecordInput!, condition: ModelRecordConditionInput): Record
  deleteRecord(input: DeleteRecordInput!, condition: ModelRecordConditionInput): Record
  createComment(input: CreateCommentInput!, condition: ModelCommentConditionInput): Comment
  updateComment(input: UpdateCommentInput!, condition: ModelCommentConditionInput): Comment
  deleteComment(input: DeleteCommentInput!, condition: ModelCommentConditionInput): Comment
  createHistory(input: CreateHistoryInput!, condition: ModelHistoryConditionInput): History
  updateHistory(input: UpdateHistoryInput!, condition: ModelHistoryConditionInput): History
  deleteHistory(input: DeleteHistoryInput!, condition: ModelHistoryConditionInput): History
  createSnapComment(input: CreateSnapCommentInput!, condition: ModelSnapCommentConditionInput): SnapComment
  updateSnapComment(input: UpdateSnapCommentInput!, condition: ModelSnapCommentConditionInput): SnapComment
  deleteSnapComment(input: DeleteSnapCommentInput!, condition: ModelSnapCommentConditionInput): SnapComment
  createQuestionSnapshot(input: CreateQuestionSnapshotInput!, condition: ModelQuestionSnapshotConditionInput): QuestionSnapshot
  updateQuestionSnapshot(input: UpdateQuestionSnapshotInput!, condition: ModelQuestionSnapshotConditionInput): QuestionSnapshot
  deleteQuestionSnapshot(input: DeleteQuestionSnapshotInput!, condition: ModelQuestionSnapshotConditionInput): QuestionSnapshot
  createQuestionSet(input: CreateQuestionSetInput!, condition: ModelQuestionSetConditionInput): QuestionSet
  updateQuestionSet(input: UpdateQuestionSetInput!, condition: ModelQuestionSetConditionInput): QuestionSet
  deleteQuestionSet(input: DeleteQuestionSetInput!, condition: ModelQuestionSetConditionInput): QuestionSet
  createQuestion(input: CreateQuestionInput!, condition: ModelQuestionConditionInput): Question
  updateQuestion(input: UpdateQuestionInput!, condition: ModelQuestionConditionInput): Question
  deleteQuestion(input: DeleteQuestionInput!, condition: ModelQuestionConditionInput): Question
}

input ModelRoomConditionInput {
  subjectId: ModelStringInput
  description: ModelStringInput
  createTime: ModelStringInput
  password: ModelStringInput
  and: [ModelRoomConditionInput]
  or: [ModelRoomConditionInput]
  not: ModelRoomConditionInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type ModelJEUserConnection {
  items: [JEUser]
  nextToken: String
}

input ModelJEUserFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  and: [ModelJEUserFilterInput]
  or: [ModelJEUserFilterInput]
  not: ModelJEUserFilterInput
}

input CreateJEUserInput {
  id: ID
  name: String
  jEUserRoomId: ID
  jEUserTeamId: ID
  jEUserTestId: ID
  jEUserHostTestId: ID
}

input UpdateJEUserInput {
  id: ID!
  name: String
  jEUserRoomId: ID
  jEUserTeamId: ID
  jEUserTestId: ID
  jEUserHostTestId: ID
}

input DeleteJEUserInput {
  id: ID
}

input ModelJEUserConditionInput {
  name: ModelStringInput
  and: [ModelJEUserConditionInput]
  or: [ModelJEUserConditionInput]
  not: ModelJEUserConditionInput
}

type ModelTeamConnection {
  items: [Team]
  nextToken: String
}

input ModelTeamFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelTeamFilterInput]
  or: [ModelTeamFilterInput]
  not: ModelTeamFilterInput
}

input CreateTeamInput {
  id: ID
  name: String
  description: String
}

input UpdateTeamInput {
  id: ID!
  name: String
  description: String
}

input DeleteTeamInput {
  id: ID
}

input ModelTeamConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  and: [ModelTeamConditionInput]
  or: [ModelTeamConditionInput]
  not: ModelTeamConditionInput
}

type ModelTestConnection {
  items: [Test]
  nextToken: String
}

input ModelTestFilterInput {
  id: ModelIDInput
  subjectId: ModelStringInput
  description: ModelStringInput
  timeBegin: ModelStringInput
  timeEnd: ModelStringInput
  status: ModelStringInput
  tags: ModelStringInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

input CreateTestInput {
  id: ID
  subjectId: String
  description: String
  timeBegin: AWSDateTime
  timeEnd: AWSDateTime
  status: String!
  tags: [String]
  testRoomId: ID
  testHostId: ID
}

input UpdateTestInput {
  id: ID!
  subjectId: String
  description: String
  timeBegin: AWSDateTime
  timeEnd: AWSDateTime
  status: String
  tags: [String]
  testRoomId: ID
  testHostId: ID
}

input DeleteTestInput {
  id: ID
}

input ModelTestConditionInput {
  subjectId: ModelStringInput
  description: ModelStringInput
  timeBegin: ModelStringInput
  timeEnd: ModelStringInput
  status: ModelStringInput
  tags: ModelStringInput
  and: [ModelTestConditionInput]
  or: [ModelTestConditionInput]
  not: ModelTestConditionInput
}

input QuesSnapshotInput {
  type: String
  name: String
  content: String
  test: String
}

type ModelRecordConnection {
  items: [Record]
  nextToken: String
}

input ModelRecordFilterInput {
  id: ModelIDInput
  subjectId: ModelStringInput
  syncCode: ModelStringInput
  timeBegin: ModelStringInput
  timeEnd: ModelStringInput
  status: ModelStringInput
  and: [ModelRecordFilterInput]
  or: [ModelRecordFilterInput]
  not: ModelRecordFilterInput
}

input CreateRecordInput {
  id: ID
  subjectId: String
  syncCode: String
  timeBegin: AWSDateTime
  timeEnd: AWSDateTime
  status: String
  ques: QuesSnapshotInput
  recordQuestionId: ID
  recordTestId: ID
  recordRoomId: ID
}

input UpdateRecordInput {
  id: ID!
  subjectId: String
  syncCode: String
  timeBegin: AWSDateTime
  timeEnd: AWSDateTime
  status: String
  ques: QuesSnapshotInput
  recordQuestionId: ID
  recordTestId: ID
  recordRoomId: ID
}

input DeleteRecordInput {
  id: ID
}

input ModelRecordConditionInput {
  subjectId: ModelStringInput
  syncCode: ModelStringInput
  timeBegin: ModelStringInput
  timeEnd: ModelStringInput
  status: ModelStringInput
  and: [ModelRecordConditionInput]
  or: [ModelRecordConditionInput]
  not: ModelRecordConditionInput
}

type ModelCommentConnection {
  items: [Comment]
  nextToken: String
}

input ModelCommentFilterInput {
  author: ModelStringInput
  time: ModelStringInput
  content: ModelStringInput
  and: [ModelCommentFilterInput]
  or: [ModelCommentFilterInput]
  not: ModelCommentFilterInput
}

input CreateCommentInput {
  author: String
  time: AWSDateTime
  content: String
  commentRecordId: ID
}

input UpdateCommentInput {
  author: String
  time: AWSDateTime
  content: String
  commentRecordId: ID
}

input DeleteCommentInput {
  id: ID
}

input ModelCommentConditionInput {
  author: ModelStringInput
  time: ModelStringInput
  content: ModelStringInput
  and: [ModelCommentConditionInput]
  or: [ModelCommentConditionInput]
  not: ModelCommentConditionInput
}

type ModelHistoryConnection {
  items: [History]
  nextToken: String
}

input ModelHistoryFilterInput {
  id: ModelIDInput
  time: ModelStringInput
  code: ModelStringInput
  and: [ModelHistoryFilterInput]
  or: [ModelHistoryFilterInput]
  not: ModelHistoryFilterInput
}

input CreateHistoryInput {
  id: ID
  time: AWSDateTime
  code: String!
  historyRecordId: ID
}

input UpdateHistoryInput {
  id: ID!
  time: AWSDateTime
  code: String
  historyRecordId: ID
}

input DeleteHistoryInput {
  id: ID
}

input ModelHistoryConditionInput {
  time: ModelStringInput
  code: ModelStringInput
  and: [ModelHistoryConditionInput]
  or: [ModelHistoryConditionInput]
  not: ModelHistoryConditionInput
}

type ModelSnapCommentConnection {
  items: [SnapComment]
  nextToken: String
}

input ModelSnapCommentFilterInput {
  id: ModelIDInput
  time: ModelStringInput
  author: ModelStringInput
  content: ModelStringInput
  and: [ModelSnapCommentFilterInput]
  or: [ModelSnapCommentFilterInput]
  not: ModelSnapCommentFilterInput
}

input CreateSnapCommentInput {
  id: ID
  time: AWSDateTime
  author: String
  content: String!
  snapCommentHistoryId: ID
}

input UpdateSnapCommentInput {
  id: ID!
  time: AWSDateTime
  author: String
  content: String
  snapCommentHistoryId: ID
}

input DeleteSnapCommentInput {
  id: ID
}

input ModelSnapCommentConditionInput {
  time: ModelStringInput
  author: ModelStringInput
  content: ModelStringInput
  and: [ModelSnapCommentConditionInput]
  or: [ModelSnapCommentConditionInput]
  not: ModelSnapCommentConditionInput
}

type ModelQuestionSnapshotConnection {
  items: [QuestionSnapshot]
  nextToken: String
}

input ModelQuestionSnapshotFilterInput {
  id: ModelIDInput
  type: ModelStringInput
  name: ModelStringInput
  content: ModelStringInput
  test: ModelStringInput
  and: [ModelQuestionSnapshotFilterInput]
  or: [ModelQuestionSnapshotFilterInput]
  not: ModelQuestionSnapshotFilterInput
}

input CreateQuestionSnapshotInput {
  id: ID
  type: String
  name: String
  content: String
  test: String
  questionSnapshotRecordId: ID
}

input UpdateQuestionSnapshotInput {
  id: ID!
  type: String
  name: String
  content: String
  test: String
  questionSnapshotRecordId: ID
}

input DeleteQuestionSnapshotInput {
  id: ID
}

input ModelQuestionSnapshotConditionInput {
  type: ModelStringInput
  name: ModelStringInput
  content: ModelStringInput
  test: ModelStringInput
  and: [ModelQuestionSnapshotConditionInput]
  or: [ModelQuestionSnapshotConditionInput]
  not: ModelQuestionSnapshotConditionInput
}

type ModelQuestionSetConnection {
  items: [QuestionSet]
  nextToken: String
}

input ModelQuestionSetFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  description: ModelStringInput
  tags: ModelStringInput
  and: [ModelQuestionSetFilterInput]
  or: [ModelQuestionSetFilterInput]
  not: ModelQuestionSetFilterInput
}

input CreateQuestionSetInput {
  id: ID
  name: String
  description: String
  tags: [String]
  questionSetTeamId: ID
}

input UpdateQuestionSetInput {
  id: ID!
  name: String
  description: String
  tags: [String]
  questionSetTeamId: ID
}

input DeleteQuestionSetInput {
  id: ID
}

input ModelQuestionSetConditionInput {
  name: ModelStringInput
  description: ModelStringInput
  tags: ModelStringInput
  and: [ModelQuestionSetConditionInput]
  or: [ModelQuestionSetConditionInput]
  not: ModelQuestionSetConditionInput
}

type ModelQuestionConnection {
  items: [Question]
  nextToken: String
}

input ModelQuestionFilterInput {
  id: ModelIDInput
  type: ModelStringInput
  name: ModelStringInput
  content: ModelStringInput
  test: ModelStringInput
  tags: ModelStringInput
  and: [ModelQuestionFilterInput]
  or: [ModelQuestionFilterInput]
  not: ModelQuestionFilterInput
}

input CreateQuestionInput {
  id: ID
  type: String
  name: String
  content: String
  test: String
  tags: [String]
  questionQuestionSetId: ID
}

input UpdateQuestionInput {
  id: ID!
  type: String
  name: String
  content: String
  test: String
  tags: [String]
  questionQuestionSetId: ID
}

input DeleteQuestionInput {
  id: ID
}

input ModelQuestionConditionInput {
  type: ModelStringInput
  name: ModelStringInput
  content: ModelStringInput
  test: ModelStringInput
  tags: ModelStringInput
  and: [ModelQuestionConditionInput]
  or: [ModelQuestionConditionInput]
  not: ModelQuestionConditionInput
}

type Test {
  id: ID!
  teamId: ID
  subjectId: String
  interviewerIds: [String]
  progress: Int
  description: String
  testDate: String
  timeBegin: Int
  timeEnd: Int
  records(filter: ModelRecordFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelRecordConnection
  complete: Boolean
}

type Record {
  id: ID!
  subjectId: String
  interviewerId: String
  timeBegin: Int
  timeEnd: Int
  history: String
  result: String
  question(filter: ModelQuestionSnapshotFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelQuestionSnapshotConnection
  test: Test
}

type QuestionSnapshot {
  id: ID!
  record: Record
  name: String
  content: String
  test: String
}

type QuestionSet {
  id: ID!
  team: Team
  questions(filter: ModelQuestionFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelQuestionConnection
  name: String
  created: Int
  updated: Int
}

type Question {
  id: ID!
  questionSet: QuestionSet
  name: String
  content: String
  test: String
  created: Int
  updated: Int
}

type Team {
  id: ID!
  name: String
  description: String
  questionSet(filter: ModelQuestionSetFilterInput, sortDirection: ModelSortDirection, limit: Int, nextToken: String): ModelQuestionSetConnection
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelTestConnection {
  items: [Test]
  nextToken: String
}

input ModelStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelIDFilterInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelIntFilterInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  contains: Int
  notContains: Int
  between: [Int]
}

input ModelFloatFilterInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  contains: Float
  notContains: Float
  between: [Float]
}

input ModelBooleanFilterInput {
  ne: Boolean
  eq: Boolean
}

input ModelTestFilterInput {
  id: ModelIDFilterInput
  teamId: ModelIDFilterInput
  subjectId: ModelStringFilterInput
  interviewerIds: ModelStringFilterInput
  progress: ModelIntFilterInput
  description: ModelStringFilterInput
  testDate: ModelStringFilterInput
  timeBegin: ModelIntFilterInput
  timeEnd: ModelIntFilterInput
  complete: ModelBooleanFilterInput
  and: [ModelTestFilterInput]
  or: [ModelTestFilterInput]
  not: ModelTestFilterInput
}

type Query {
  getTest(id: ID!): Test
  listTests(filter: ModelTestFilterInput, limit: Int, nextToken: String): ModelTestConnection
  getRecord(id: ID!): Record
  listRecords(filter: ModelRecordFilterInput, limit: Int, nextToken: String): ModelRecordConnection
  getQuestionSnapshot(id: ID!): QuestionSnapshot
  listQuestionSnapshots(filter: ModelQuestionSnapshotFilterInput, limit: Int, nextToken: String): ModelQuestionSnapshotConnection
  getQuestionSet(id: ID!): QuestionSet
  listQuestionSets(filter: ModelQuestionSetFilterInput, limit: Int, nextToken: String): ModelQuestionSetConnection
  getQuestion(id: ID!): Question
  listQuestions(filter: ModelQuestionFilterInput, limit: Int, nextToken: String): ModelQuestionConnection
  getTeam(id: ID!): Team
  listTeams(filter: ModelTeamFilterInput, limit: Int, nextToken: String): ModelTeamConnection
}

input CreateTestInput {
  teamId: ID
  subjectId: String
  interviewerIds: [String]
  progress: Int
  description: String
  testDate: String
  timeBegin: Int
  timeEnd: Int
  complete: Boolean
}

input UpdateTestInput {
  id: ID!
  teamId: ID
  subjectId: String
  interviewerIds: [String]
  progress: Int
  description: String
  testDate: String
  timeBegin: Int
  timeEnd: Int
  complete: Boolean
}

input DeleteTestInput {
  id: ID
}

type Mutation {
  createTest(input: CreateTestInput!): Test
  updateTest(input: UpdateTestInput!): Test
  deleteTest(input: DeleteTestInput!): Test
  createRecord(input: CreateRecordInput!): Record
  updateRecord(input: UpdateRecordInput!): Record
  deleteRecord(input: DeleteRecordInput!): Record
  createQuestionSnapshot(input: CreateQuestionSnapshotInput!): QuestionSnapshot
  updateQuestionSnapshot(input: UpdateQuestionSnapshotInput!): QuestionSnapshot
  deleteQuestionSnapshot(input: DeleteQuestionSnapshotInput!): QuestionSnapshot
  createQuestionSet(input: CreateQuestionSetInput!): QuestionSet
  updateQuestionSet(input: UpdateQuestionSetInput!): QuestionSet
  deleteQuestionSet(input: DeleteQuestionSetInput!): QuestionSet
  createQuestion(input: CreateQuestionInput!): Question
  updateQuestion(input: UpdateQuestionInput!): Question
  deleteQuestion(input: DeleteQuestionInput!): Question
  createTeam(input: CreateTeamInput!): Team
  updateTeam(input: UpdateTeamInput!): Team
  deleteTeam(input: DeleteTeamInput!): Team
}

type Subscription {
  onCreateTest: Test @aws_subscribe(mutations: ["createTest"])
  onUpdateTest: Test @aws_subscribe(mutations: ["updateTest"])
  onDeleteTest: Test @aws_subscribe(mutations: ["deleteTest"])
  onCreateRecord: Record @aws_subscribe(mutations: ["createRecord"])
  onUpdateRecord: Record @aws_subscribe(mutations: ["updateRecord"])
  onDeleteRecord: Record @aws_subscribe(mutations: ["deleteRecord"])
  onCreateQuestionSnapshot: QuestionSnapshot @aws_subscribe(mutations: ["createQuestionSnapshot"])
  onUpdateQuestionSnapshot: QuestionSnapshot @aws_subscribe(mutations: ["updateQuestionSnapshot"])
  onDeleteQuestionSnapshot: QuestionSnapshot @aws_subscribe(mutations: ["deleteQuestionSnapshot"])
  onCreateQuestionSet: QuestionSet @aws_subscribe(mutations: ["createQuestionSet"])
  onUpdateQuestionSet: QuestionSet @aws_subscribe(mutations: ["updateQuestionSet"])
  onDeleteQuestionSet: QuestionSet @aws_subscribe(mutations: ["deleteQuestionSet"])
  onCreateQuestion: Question @aws_subscribe(mutations: ["createQuestion"])
  onUpdateQuestion: Question @aws_subscribe(mutations: ["updateQuestion"])
  onDeleteQuestion: Question @aws_subscribe(mutations: ["deleteQuestion"])
  onCreateTeam: Team @aws_subscribe(mutations: ["createTeam"])
  onUpdateTeam: Team @aws_subscribe(mutations: ["updateTeam"])
  onDeleteTeam: Team @aws_subscribe(mutations: ["deleteTeam"])
}

type ModelRecordConnection {
  items: [Record]
  nextToken: String
}

input ModelRecordFilterInput {
  id: ModelIDFilterInput
  subjectId: ModelStringFilterInput
  interviewerId: ModelStringFilterInput
  timeBegin: ModelIntFilterInput
  timeEnd: ModelIntFilterInput
  history: ModelStringFilterInput
  result: ModelStringFilterInput
  and: [ModelRecordFilterInput]
  or: [ModelRecordFilterInput]
  not: ModelRecordFilterInput
}

input CreateRecordInput {
  subjectId: String
  interviewerId: String
  timeBegin: Int
  timeEnd: Int
  history: String
  result: String
  recordTestId: ID
}

input UpdateRecordInput {
  id: ID!
  subjectId: String
  interviewerId: String
  timeBegin: Int
  timeEnd: Int
  history: String
  result: String
  recordTestId: ID
}

input DeleteRecordInput {
  id: ID
}

type ModelQuestionSnapshotConnection {
  items: [QuestionSnapshot]
  nextToken: String
}

input ModelQuestionSnapshotFilterInput {
  id: ModelIDFilterInput
  name: ModelStringFilterInput
  content: ModelStringFilterInput
  test: ModelStringFilterInput
  and: [ModelQuestionSnapshotFilterInput]
  or: [ModelQuestionSnapshotFilterInput]
  not: ModelQuestionSnapshotFilterInput
}

input CreateQuestionSnapshotInput {
  name: String
  content: String
  test: String
  questionSnapshotRecordId: ID
}

input UpdateQuestionSnapshotInput {
  id: ID!
  name: String
  content: String
  test: String
  questionSnapshotRecordId: ID
}

input DeleteQuestionSnapshotInput {
  id: ID
}

type ModelQuestionSetConnection {
  items: [QuestionSet]
  nextToken: String
}

input ModelQuestionSetFilterInput {
  id: ModelIDFilterInput
  name: ModelStringFilterInput
  created: ModelIntFilterInput
  updated: ModelIntFilterInput
  and: [ModelQuestionSetFilterInput]
  or: [ModelQuestionSetFilterInput]
  not: ModelQuestionSetFilterInput
}

input CreateQuestionSetInput {
  name: String
  created: Int
  updated: Int
  questionSetTeamId: ID
}

input UpdateQuestionSetInput {
  id: ID!
  name: String
  created: Int
  updated: Int
  questionSetTeamId: ID
}

input DeleteQuestionSetInput {
  id: ID
}

type ModelQuestionConnection {
  items: [Question]
  nextToken: String
}

input ModelQuestionFilterInput {
  id: ModelIDFilterInput
  name: ModelStringFilterInput
  content: ModelStringFilterInput
  test: ModelStringFilterInput
  created: ModelIntFilterInput
  updated: ModelIntFilterInput
  and: [ModelQuestionFilterInput]
  or: [ModelQuestionFilterInput]
  not: ModelQuestionFilterInput
}

input CreateQuestionInput {
  name: String
  content: String
  test: String
  created: Int
  updated: Int
  questionQuestionSetId: ID
}

input UpdateQuestionInput {
  id: ID!
  name: String
  content: String
  test: String
  created: Int
  updated: Int
  questionQuestionSetId: ID
}

input DeleteQuestionInput {
  id: ID
}

type ModelTeamConnection {
  items: [Team]
  nextToken: String
}

input ModelTeamFilterInput {
  id: ModelIDFilterInput
  name: ModelStringFilterInput
  description: ModelStringFilterInput
  and: [ModelTeamFilterInput]
  or: [ModelTeamFilterInput]
  not: ModelTeamFilterInput
}

input CreateTeamInput {
  name: String
  description: String
}

input UpdateTeamInput {
  id: ID!
  name: String
  description: String
}

input DeleteTeamInput {
  id: ID
}
